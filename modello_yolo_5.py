# -*- coding: utf-8 -*-
"""modello_YOLO_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14qfwCxswo_CIVmX1cYOR8byMJFHSMi2U
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
!pip install -r requirements.txt

# Import Essential Libraries
import os
import random
import pandas as pd
from PIL import Image
import cv2
from ultralytics import YOLO
from IPython.display import Video
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='darkgrid')
import pathlib
import glob
from tqdm.notebook import trange, tqdm
import warnings
import torch
from tqdm import tqdm
from collections import Counter
import shutil
import albumentations as A
from matplotlib import pyplot as plt
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/drive')

# Configure the visual appearance of Seaborn plots
sns.set(rc={'axes.facecolor': '#eae8fa'}, style='darkgrid')

def resize_images_in_folder(folder_path, new_size=(640, 640)):
    image_extensions = ('.jpg', '.jpeg', '.png')
    image_files = [f for f in os.listdir(folder_path) if f.lower().endswith(image_extensions)]

    for file_name in tqdm(image_files, desc=f"Resizing in {folder_path}"):
        image_path = os.path.join(folder_path, file_name)
        with Image.open(image_path) as img:
            img_resized = img.resize(new_size, Image.Resampling.LANCZOS)
            img_resized.save(image_path)

# Percorsi alle cartelle di immagini
base_path = "/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car"

folders = ["train/images", "val/images", "test/images"]
for folder in folders:
    full_path = os.path.join(base_path, folder)
    resize_images_in_folder(full_path)

def count_classes_in_labels(folder_path):
    label_files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]
    class_counter = Counter()

    for file_name in tqdm(label_files, desc=f"Counting in {folder_path}"):
        file_path = os.path.join(folder_path, file_name)
        with open(file_path, 'r') as f:
            for line in f:
                if line.strip():  # Skip empty lines
                    class_id = int(line.split()[0])
                    class_counter[class_id] += 1

    return class_counter

# Percorsi alle cartelle di label
base_path = "/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car"
folders = ["train/labels", "val/labels", "test/labels"]

total_counter = Counter()
for folder in folders:
    full_path = os.path.join(base_path, folder)
    class_counts = count_classes_in_labels(full_path)
    print(f"\nClass counts in {folder}:")
    for class_id in range(15):  # 15 classi
        print(f"Classe {class_id}: {class_counts.get(class_id, 0)}")
    total_counter.update(class_counts)

print("\n==> Totale su tutto il dataset:")
for class_id in range(15):
    print(f"Classe {class_id}: {total_counter.get(class_id, 0)}")

''' DATA AUGMENTATION
# === PARAMETRI ===
target_classes = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14]
augmentations_per_image = 3

# === AUGMENTATION SICURE ===
transform = A.Compose([
    A.RandomBrightnessContrast(p=0.5),
    A.MotionBlur(p=0.2),
    A.GaussNoise(p=0.3),
    A.HueSaturationValue(p=0.3)
], bbox_params=A.BboxParams(format='yolo', label_fields=['class_labels']))

def augment_for_classes(images_path, labels_path, out_img_path, out_lbl_path):
    os.makedirs(out_img_path, exist_ok=True)
    os.makedirs(out_lbl_path, exist_ok=True)

    files = [f for f in os.listdir(labels_path) if f.endswith('.txt')]

    for file in tqdm(files, desc="Augmenting images"):
        label_file = os.path.join(labels_path, file)
        with open(label_file, 'r') as f:
            lines = f.readlines()

        # Controlla se contiene almeno una classe target
        if not any(int(float(line.split()[0])) in target_classes for line in lines):
            continue

        image_file = os.path.join(images_path, file.replace('.txt', '.jpg'))
        if not os.path.exists(image_file):
            image_file = image_file.replace('.jpg', '.png')
            if not os.path.exists(image_file):
                continue

        image = cv2.imread(image_file)
        if image is None:
            continue

        bboxes = []
        class_labels = []
        for line in lines:
            parts = line.strip().split()
            # Conversione sicura da float a int
            cls = int(float(parts[0]))
            bbox = list(map(float, parts[1:]))
            bboxes.append(bbox)
            class_labels.append(cls)

        for i in range(augmentations_per_image):
            transformed = transform(image=image, bboxes=bboxes, class_labels=class_labels)
            aug_img = transformed['image']
            aug_bboxes = transformed['bboxes']
            aug_labels = transformed['class_labels']

            # Salta se non ci sono più bbox (oggetti visibili)
            if len(aug_bboxes) == 0:
                continue

            new_img_name = file.replace('.txt', f'_aug{i}.jpg')
            new_lbl_name = file.replace('.txt', f'_aug{i}.txt')

            cv2.imwrite(os.path.join(out_img_path, new_img_name), aug_img)
            with open(os.path.join(out_lbl_path, new_lbl_name), 'w') as f:
                for cls, bbox in zip(aug_labels, aug_bboxes):
                    # Riscrive sempre la classe come intero
                    f.write(f"{int(cls)} {' '.join(map(str, bbox))}\n")

# === Percorsi ===
base_path = "/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car"
train_images = os.path.join(base_path, "train/images")
train_labels = os.path.join(base_path, "train/labels")
aug_images = os.path.join(base_path, "train/images_aug")
aug_labels = os.path.join(base_path, "train/labels_aug")

# === STEP 1: DATA AUGMENTATION ===
augment_for_classes(train_images, train_labels, aug_images, aug_labels)

# === STEP 2: SPOSTA I FILE AUGMENTATI NELLE CARTELLE FINALI ===
for file in os.listdir(aug_images):
    shutil.move(os.path.join(aug_images, file), os.path.join(train_images, file))

for file in os.listdir(aug_labels):
    shutil.move(os.path.join(aug_labels, file), os.path.join(train_labels, file))

# === STEP 3: RIMUOVI LE CARTELLE TEMPORANEE ===
shutil.rmtree(aug_images)
shutil.rmtree(aug_labels)

print("Augmentation completata. File spostati e cartelle temporanee rimosse.")

'''

''' CONTO ELEMENTI PER CLASSE
def count_classes_in_labels(folder_path):
    label_files = [f for f in os.listdir(folder_path) if f.endswith('.txt')]
    class_counter = Counter()

    for file_name in tqdm(label_files, desc=f"Counting in {folder_path}"):
        file_path = os.path.join(folder_path, file_name)
        with open(file_path, 'r') as f:
            for line in f:
                if line.strip():  # Skip empty lines
                    class_id = int(line.split()[0])
                    class_counter[class_id] += 1

    return class_counter

# Percorsi alle cartelle di label
base_path = "/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car"
folders = ["train/labels", "val/labels", "test/labels"]

total_counter = Counter()
for folder in folders:
    full_path = os.path.join(base_path, folder)
    class_counts = count_classes_in_labels(full_path)
    print(f"\nClass counts in {folder}:")
    for class_id in range(15):  # 15 classi
        print(f"Classe {class_id}: {class_counts.get(class_id, 0)}")
    total_counter.update(class_counts)

print("\n==> Totale su tutto il dataset:")
for class_id in range(15):
    print(f"Classe {class_id}: {total_counter.get(class_id, 0)}")

#Questo codice Python serve a visualizzare 9 immagini selezionate casualmente da una cartella (Image_dir) in una griglia 3x3 usando matplotlib
# Percorso delle immagini
Image_dir = '/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car/train/images'

num_samples = 9
image_files = os.listdir(Image_dir)

# Seleziona casualmente num_samples immagini
rand_images = random.sample(image_files, num_samples)

fig, axes = plt.subplots(3, 3, figsize=(11, 11))

for i in range(num_samples):
    image = rand_images[i]
    ax = axes[i // 3, i % 3]
    image_path = os.path.join(Image_dir, image)
    ax.imshow(plt.imread(image_path))
    ax.set_title(f'Image {i+1}')
    ax.axis('off')

plt.tight_layout()
plt.show()

#Codice per ottenere le dimensioni delle immagini
# Percorso corretto all'immagine su Windows
image_path = '/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car/train/images/00000_00000_00027_png.rf.f6c9b515022704235dad9ac1652c8814.jpg'

# Legge l'immagine
image = cv2.imread(image_path)

# Controlla che l'immagine sia stata caricata correttamente
if image is not None:
    h, w, c = image.shape
    print(f"L'immagine ha dimensioni {w}x{h} e {c} canali.")
else:
    print("Errore nel caricamento dell'immagine. Controlla il percorso.")

# Applica il modello YOLOv8 all'immagine con una dimensione di input di 640x640 pixel. Il risultato è un oggetto che contiene le predizioni (box, classi, confidenza).
model = torch.hub.load('ultralytics/yolov5', 'yolov5n', pretrained=True)

# Use the model to detect object
image = '/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car/train/images/road868_png.rf.2527789265fff34beffcf92d207652ab.jpg'
results = model('/content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car/train/images/road868_png.rf.2527789265fff34beffcf92d207652ab.jpg')
results.print()
results.show()

!python train.py --img 640 --batch 16 --epochs 10 \
--data /content/drive/MyDrive/Colab_Notebooks/Progetto_Edge_ML/car/data.yaml \
--weights yolov5n.pt --name yolov5_custom

#creazione file best.pt:
!python export.py --weights runs/train/yolov5_custom/weights/best.pt --include onnx --img 640


#Scarica modello:
from google.colab import files
files.download('/content/yolov5/runs/train/yolov5_custom/weights/best.pt')

# Carica il modello YOLOv5
model = torch.hub.load('ultralytics/yolov5', 'custom', path='/content/best1.pt', force_reload=True)

# Percorso all'immagine
image_path = '/content/prova.png'

# Inference
results = model(image_path)
results.print()
results.show()